# Arrakis: The Operating System is the Control Plane 阅读笔记

随着现在的IO设备越来越快，操作系统本身的开销成为了IO的性能瓶颈。在这篇paper中，作者提出并实现了Arrakis。该操作系统使用了IO虚拟化技术，使得很多I/O操作能够直接跳过内核，使得性能有了很大的提高。它的延迟有了2-5倍的提高，带宽有了9倍的提升。

### 现有的操作系统的I/O开销
在网络的I/O操作中，操作系统的开销主要有以下几点：
* 网络协议栈的开销
* 调度的开销
* 内核态和用户态切换的开销
* 拷贝数据的开销

在文件系统中，主要的开销有：
* 数据拷贝
* 参数检查
* 分配block和inode
* 虚拟化
* 写入日志


### Arrakis的硬件支持

* VNIC:虚拟的网卡，能够根据复杂的条件筛选，将包直接发给用户态的进程，而不需要内核的支持。每个VNIC上都有自己的队列。能够验证包头的信息来保证安全。还能通过Filter来选择自己想要监听的端口。
* VSIC:虚拟的存储控制器，能够从硬件上虚拟出很多个VSA。进程可以读写其中的数据。而一个进程可以得到多个VSA来共享数据。

### Arrakis的接口与实现

* 每个进程创建和删除自己的VIC。也可以通过filter，来过滤自己需要的信息。
* 每个进程可以直接操作VSA，来管理数据。进程可以通过Kernel，将其他的进程的VSA所暴露出来的文件系统 mount到自己的进程中，并通过用户态的IPC来访问。最后，用户能够通过kernel所提供的file system来访问文件。
* 网络协议同时提供了zero-copy的接口和Posix兼容的接口。
* 同时，Arrakis实现了自己特有的可持久化的队列和log的接口。

### 和其他相关工作的对比

Arrakis没有使用batch，使得它的latency很低。同时，它在提供POSIX兼容接口的同时，还能够让程序直接访问硬件，进而提高了性能。

### 运行Arrakis

在本地装好haskell的依赖库，使用gcc4.4来编译Arrakis所自带的代码。中间有可能出现编译不通过的情况，这是因为当前的机器没有运行系统所需要的网卡和RAID卡导致的。此时，通过修改menu.lst文件，剔除掉一些模块，就能够编译通过了。此时，通过make qemu就能在qemu中运行Arrakis了。此时Arrakis会模拟相应的存储和网卡来运行，不过性能会低很多。